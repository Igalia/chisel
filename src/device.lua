---
-- Descriptions for devices.
--
-- This module provides functionality to describe the capabilities
-- of actual devices. Also, it supports generation of [PPD
-- files](http://en.wikipedia.org/wiki/PostScript_Printer_Description)
-- suitable to be used with [CUPS](http://cups.org)
--
-- @copyright 2012 Adrian Perez <aperez@igalia.com>
-- @license Distributed under terms of the MIT license.
--

local sprintf  = string.format
local tconcat  = table.concat
local mfloor   = math.floor
local loadfile = loadfile
local tostring = tostring
local ipairs   = ipairs
local pairs    = pairs
local pcall    = pcall
local type     = type
local isdir    = fs.isdir
local listdir  = fs.listdir
local imap     = lib.ml.imap
local ifilter  = lib.ml.ifilter
local extend   = lib.ml.extend
local callable = lib.ml.callable
local rupdate  = lib.util.rupdate
local u_to_mm  = lib.util.u_to_mm


local function ppd_attribute (ppdname, attrname, optional)
	return function (data)
		if data[attrname] == nil then
			if optional then
				return sprintf ("*%% Attribute %s (%s) is undefined", ppdname, attrname)
			end
			error ("No attribute '" .. attrname .. "' in device data", 2)
		end
		return sprintf ("*%s: \"%s\"", ppdname, data[attrname])
	end
end


-- Template for generated PPD files:
--
--	* Strings are emitted as-is, followed by a newline character.
--	* Functions are called passing the device data object as only
--	  argument. They should return a string, which will get emitted
--	  as output.
--
local ppd_template = {
	-- Standard PPD header, and info blob
	[[*PPD-Adobe: "4.3"]];
	[[*%]];
	[[*% PPD generated by chisel-ppd version ]] .. chisel.version;
	[[*%]];

	-- XXX Those hardcoded values should go away at some point!
	[[*LanguageVersion: English]],
	[[*LanguageEncoding: Latin1]],

	-- Manufacturer, model names, etc
	ppd_attribute ("1284DeviceID", "ieee1284_id", true);
	ppd_attribute ("Manufacturer", "manufacturer");
	ppd_attribute ("ModelName",    "model");
	ppd_attribute ("Throughput",   "throughput", true);

	-- Extra redundant model infos which can be derived from the above
	function (data)
		return sprintf ("*Product: \"(%s)\"\n\z
			               *ShortNickName: \"%s\"\n\z
			               *NickName: \"%s %s\"",
										 data.model, data.model,
										 data.manufacturer, data.model)
	end;

  -- Filter command, and renderer to use, for use with CUPS, aka the
  -- chisel{Renderer,DeviceId} attributes (see comment below).
  [[*cupsVersion: 1.2]];
  [[*cupsFilter: "application/x-chisel-text 0 chiseltodev"]];
  function (data)
    return sprintf ("*chiselDeviceId: \"%s\"", data.id)
  end;
  function (data)
    if data.renderer then
      -- XXX Maybe it would be better to use the cupsModelNumber attribute,
      -- but it is an integer value and then it would be needed to keep a
      -- deviceId <-> modelNumber mapping, and also generating unique
      -- modelNumber atributes in a "stable" way that does not change
      -- between invocations. Therefore, just add a chiselRenderer
      -- attribute (to be ignored by other applications), which the
      -- backend could parse if needed.
      return sprintf ("*chiselRenderer: \"%s\"", data.output)
    else
      return "*% No 'renderer' option defined, skipping chiselRenderer attribute"
    end
  end;

	-- Color model
	function (data)
		local colors = data.colorspace
		local retval = "*ColorDevice: False\n\z
			              *DefaultColorSpace: Gray"

		if colors == nil then
			colors = "gray"
		end

		-- For the moment, only grayscale is supported. Anything else
		-- causes an error to be raised.
		if colors ~= "gray" and colors ~= "grey" then
			error ("Color space '" .. tostring (colors) .. "' is not supported")
		end
		return retval
	end;

	-- PPD file versions. For the file version, pick chisel.version, and add
	-- the revision number from the printer data in between parentheses.
	[[*FormatVersion: "4.3"]],
	[[*PSVersion: "(3000.000) 100"]],
	function (data)
		return sprintf ("*FileVersion: \"%s(%i)\"",
		                chisel.version,
		                data.revision or 0)
	end;

	-- Generate options. This deserves a separate function...
	function (data)
		if not data.options then
			return "*% No options defined"
		end

		local result = {}
		for k, opt in pairs (data.options) do
			log_debug ("%s, %s, %s\n", k, opt, opt.ppd)
			if callable (opt.ppd) then
				result[#result+1] = sprintf ("\n*%% options.%s", k)
				result[#result+1] = opt:ppd ()
			else
				result[#result+1] = sprintf ("\n*%% options.%s has no PPD equivalent", k)
			end
		end

		return tconcat (result, "\n")
	end;
}

--- Built-in option values
-- @section buitin_values

--- Built-in page sizes
local builtin_pagesizes =
{
	A3     = "A3";        -- Standard DIN A3 paper
	A4     = "A4";        -- Standard DIN A4 paper
	A5     = "A5";        -- Standard DIN A5 paper
	Legal  = "US Legal";  -- Standard US Legal paper
	Letter = "US Letter"; -- Standard US Letter paper
}

--- Built-in duplex operation values
local builtin_duplex =
{
	None     = "Off";               -- Duplex is disabled
	Tumble   = "Top Edge Binding";  -- Turn page on short (top) side
	NoTumble = "Left Edge Binding"; -- Turn page on long (left) side
}

--- Built-in media sizes
local builtin_media =
{
	Letter = { size={ 612;         792        } }; -- Standard US Letter paper
	Legal  = { size={ 612;        1008        } }; -- Standard US Legal paper
	A3     = { size={ 841.889765; 1190.551180 } }; -- Standard DIN A3 paper
	A4     = { size={ 595.275590;  841.889765 } }; -- Standard DIN A4 paper
	A5     = { size={ 419.527560;  595.275590 } }; -- Standard DIN A5 paper
}


--- Device data.
-- @section device_data

--- Device option.
--
-- Describes a device option. The following attributes can (and should) be
-- defined:
--
--  * `name`: Name of the option (mandatory).
--  * `ppd_name`: Name of the option in a PPD file (optional, if different
--    from `name`).
--  * `ppd_type`: Type of the PPD option (e.g. `PickOne`, mandatory).
--  * `desc`: Long description suited for displaying to users (mandatory).
--  * `ppd_desc`: Long description of the option, to use in PPDs (optional,
--     if different from `desc`).
--  * `default`: Default value (optional).
--  * `ppd_default`: Attribute used in the PPD to define the default value
--    (optional).
--  * `values`: Possible values for the option (optional, needed for
--    `PickOne` options).
--  * `ui`: The option does have an UI, i.e. in the generated PPD
--     there will be both an `*OpenUI` and a `*CloseUI` statement
--     for the option. By default it is set to `true`.
--
-- @table option
--
local option = object:extend
{
	--- Generate a code snippet suitable for inclusion in a PPD.
	--
	-- @name option:ppd
	--
	ppd = function (self)
		local name = self.ppd_name or self.name
		local desc = self.ppd_desc or self.desc or name
		local r = {}

		if self.comment then
			r[#r+1] = sprintf ("*%% %s", self.comment)
		end

		if self.ui then
			r[#r+1] = sprintf ("*OpenUI *%s/%s: %s", name, desc, self.ppd_kind)
		end

		if self.default then
			if self.ppd_default then
				r[#r+1] = sprintf ("*%s: %s", self.ppd_default, self.default)
			else
				r[#r+1] = sprintf ("*Default%s: %s", name, self.default)
			end
		end

		if self.values then
			for k, v in pairs (self.values) do
				if type (v) == "table" then
					r[#r+1] = sprintf ("*%s %s/%s: \"%s\"", name, k, v[1], v[2])
				else
					r[#r+1] = sprintf ("*%s %s/%s: \"\"", name, k, v)
				end
			end
		end

		if self.ui then
			r[#r+1] = sprintf ("*CloseUI: *%s\n", name)
		end

		return tconcat (r, "\n")
	end;

	-- Enabled by default.
	ui = true;
}


local option_class =
{
	pagesize       = option:extend { name = "PageSize";   ppd_kind = "PickOne"; desc = "Media Size" };
	pageregion     = option:extend { name = "PageRegion"; ppd_kind = "PickOne" };
	duplex         = option:extend { name = "Duplex";     ppd_kind = "PickOne" };
	paperdimension = option:extend { name = "PaperDimension"; ui = false };
	imageablearea  = option:extend { name = "ImageableArea" ; ui = false };
}


local function _device_get (name)
	local base = {}
	local data = {}
	local path = sprintf ("%s/data/%s.lua", chisel.libdir, name)

	-- Load the chunk, if there is some error, return nil+error
	local chunk, err = loadfile (path, "t", data)
	if chunk == nil  then
		return nil, e
	end
	chunk, err = pcall (chunk)

	if not chunk then
		return nil, err
	end

	if data.base then
		base, err = _device_get (data.base)
		if base == nil then
			return nil, err
		end
	end

	-- TODO Merging of items works recursively, but array-tables may not
	--      behave as expected. Beware, dragons ahead.
	rupdate (base, data)
	base.id = name
	return base
end


local function option_gather_function (name, builtins, optclass)
	return function (self, ps)
		if type (ps) ~= "table" then
			error (name .. "s must be a table/list")
		end

		local vals = {}
		for k, v in pairs (ps) do
			if type (k) == "number" then
				-- Numeric index, pick built-in value
				if builtins[v] == nil then
					error ("unknown bultin " .. name .. " '" .. v .. "'")
				end
				log_debug (" adding builtin %s '%s'\n", name, v)
				vals[v] = builtins[v]
			else
				-- Pick value as-is
				log_debug (" adding %s '%s' (%s)\n", name, k, v)
				vals[k] = v
			end
		end

		local defval = vals.default
		vals.default = nil

		return optclass:clone { values = vals, default = defval }
	end
end


local function calculate_iarea_and_paperdim (psize, media)
	local iarea = {}
	local ppdim = {}

	for name, attributes in pairs (media) do
		if not attributes.margins then
			error ("no margins specified for media '" .. name .. "'")
		end

		iarea[name] = attributes.margins

		if attributes.size then
			ppdim[name] = attributes.size
		elseif builtin_media[name] ~= nil then
			ppdim[name] = builtin_media[name].size
		else
			error ("size not specified for media '" .. name .. "'")
		end

		iarea[name] = { psize.values[name];
			              sprintf ("%.6f %.6f %.6f %.6f", table.unpack (iarea[name])) }
		ppdim[name] = { psize.values[name];
	                  sprintf ("%.6f %.6f", table.unpack (ppdim[name])) }
	end

	return option_class.imageablearea:clone  { default=psize.default; values=iarea },
	       option_class.paperdimension:clone { default=psize.default; values=ppdim }
end


--- Device data base class.
--
-- The `device` is a class used to describe devices (printers, embossers).
--
-- @todo Describe fields recognized, and how to make a minimal, valid
-- device data file.
--
-- @table device
--
local device = object:extend
{
	init = function (self)
		log_debug ("device:init: %s/%s\n", self.manufacturer, self.model)

		self.default = {}

		if self.options then
			for k, v in pairs (self.options) do
				log_debug ("device:init: default %s = %s\n", k, v.default)
				self.default[k] = v.default
				local opt_init_func = self["_init_option_" .. k]
				log_debug ("device:_init_option_%s: %s\n", k, opt_init_func)
				if opt_init_func then
					self.options[k] = opt_init_func (self, v)
				end
			end

			if not self.options.pagesize then
				error ("no options.pagesize defined")
			end

			-- If there is no "pageregion" options, create one by copying from
			-- an existing "pagesize" one.
			if self.options.pageregion == nil then
				self.options.pageregion = option_class.pageregion:clone {
					values  = self.options.pagesize.values,
					default = self.options.pagesize.default,
					comment = "Note: copied from options.pagesize",
				}
			end
		end

		if self.media then
			self.options.imageablearea, self.options.paperdimension =
				calculate_iarea_and_paperdim (self.options.pagesize, self.media)
		end

		local lpp, cpl = self:calculate_text_area ()
		if self.default.lines_per_page == nil then
			self.default.lines_per_page = lpp
		end
		if self.default.characters_per_line == nil then
			self.default.characters_per_line = cpl
		end

		return self
	end;

	_init_option_duplex = option_gather_function ("duplex mode",
	                                              builtin_duplex,
	                                              option_class.duplex);

	_init_option_pagesize = option_gather_function ("page size",
	                                                builtin_pagesizes,
	                                                option_class.pagesize);

	_init_option_pageregion = option_gather_function ("page region",
	                                                  builtin_pagesizes,
	                                                  option_class.pageregion);

	--- Generates PPD data.
	--
	-- @return String wiht the contents of the PPD.
	-- @name device:ppd
	--
	ppd = function (self)
		local result = {}
		for _, v in ipairs (ppd_template) do
			if type (v) == "function" then
				v = v (self)
			else
				v = tostring (v)
			end
			result[#result+1] = v
		end
		return tconcat (result, "\n")
	end;

  --- Instantiates a renderer suitable for sending data to the device.
  --
  -- @return A @{renderer} instance.
  -- @function device:create_renderer
  --
  create_renderer = function (self, writef)
    local rend, err = lib.renderer.get (self.renderer, writef)
    if rend ~= nil then
      rend.device = self
    end
    return rend, err
  end;


  --- Obtains supported media information.
  --
  -- @param name Name of the media, e.g. `"Letter"`, `"A4"`, or any other
  -- device-specific format listed in the `media` attribute.
  -- @return Table containing information about the media, or `nil` if the
  -- requested media does is not supported by the device.
  -- @function device:get_media_info
  --
  get_media_info = function (self, name)
    if self.media[name] == nil then
      return nil
    end

    local margins = self.media[name].margins
    assert (margins ~= nil)

    local mediasize = self.media[name].size or builtin_media[name].size
    assert (mediasize ~= nil)

    return {
      name          = name;
      width         = mediasize[1];
      height        = mediasize[2];
      top_margin    = margins[1];
      left_margin   = margins[2];
      right_margin  = margins[3];
      bottom_margin = margins[4];
    }
  end;

  --- Calculate text area.
  --
  -- @param dot_distance
  -- @param line_spacing
  -- @param pagesize
  -- @return Lines-per-page and characters-per-line (both numbers)
  -- @function device:calculate_text_area
  --
  calculate_text_area = function (self, dot_distance, line_spacing, cell_spacing, pagesize)
    -- Pick defaults if needed
    dot_distance = dot_distance or self.default.dot_distance
    line_spacing = line_spacing or self.default.line_spacing
    cell_spacing = cell_spacing or self.default.cell_spacing
    pagesize = pagesize or self.default.pagesize

    -- Line spacing may be a string: ensure it is a numeric value.
    if type (line_spacing) == "string" then
      line_spacing = self.options.line_spacing[line_spacing]
    end
    assert (tonumber (line_spacing))

    -- Dot distance may be a string: ensure it is a numeric value.
    if type (dot_distance) == "string" then
      dot_distance = self.options.dot_distance[dot_distance]
    end
    assert (tonumber (dot_distance))

    -- The given page_size may be a string, in that case pick the actual
    -- dimensions from the list of supported media.
    if type (pagesize) == "string" then
      pagesize = self:get_media_info (pagesize)
    end

    -- XXX Sizes in data files are in PostScript Default Units, convert.
    local h = u_to_mm (pagesize.bottom_margin - pagesize.top_margin)
    local w = u_to_mm (pagesize.right_margin - pagesize.left_margin)

    --
    --  dot_distance        |  cell_w = 1 * dot_distance + cell_spacing
    --   |                  |  cell_h = 2 * dot_distance + line_spacing
    --   | cell_spacing
    --   |  |
    --   /\/\
    --  .____.
    --  |**  |\__ dot_distance
    --  |**  |/
    --  |**  |
    --  |    |\__ line_spacing
    --  |____|/
    --

    local cell_w = 1 * dot_distance + cell_spacing
    local cell_h = 2 * dot_distance + line_spacing

    local characters_per_line = mfloor (w / cell_w)
    local lines_per_page = mfloor (h / cell_h)
    return lines_per_page, characters_per_line
  end;
}


--- Obtain the data for a device given its name.
--
-- @param name Device name in `manufacturer/model` form.
-- @function device.get
--
function device.get (name)
	return device:clone (_device_get (name)) :init()
end;


local function is_valid_manufacturer (item)
  return item:sub (1, 1) ~= "_" and
         isdir (chisel.libdir .. "/data/" .. item)
end

--- List supported devices and manufacturers.
--
-- @param manufacturer Omitting the argument, returns a list of all the
-- manufacturers. When specifying the argument, the devices supported
-- from a particular manufacturer are returned. Passing the string
-- `"*"` as manufacturer will return _all_ devices of _all_
-- manufacturers. *(Optional)*.
--
-- @return List with device names in `<manufacturer>/<device>` format.
-- @function device.list
--
local list_devices
function list_devices (manufacturer)
  if manufacturer == nil then
    -- List all manufacturers
    return ifilter (listdir (chisel.libdir .. "/data"), is_valid_manufacturer)
  elseif manufacturer == "*" then
    -- List all models of all manufacturers
    local result = {}
    for _, mf in ipairs (list_devices ()) do
      extend (result, list_devices (mf))
    end
    return result
  else
    -- List models for a particular manufacturer
    local function is_valid_device_name (item)
      return item:sub (1, 1) ~= "_" and
             not isdir (chisel.libdir .. "/data/" .. manufacturer .. "/" .. item)
    end

    local function fix_name (item)
      -- Prepend the manufacturer and remove the ".lua" suffix
      return manufacturer .. "/" .. item:sub (1, -5)
    end

    if not is_valid_manufacturer (manufacturer) then
      -- XXX Maybe would it be better to call error() here?
      return {}
    end

    -- List files for the manufacturer directory, filter out invalid
    -- names, and prepare the names in a format suitable for returning.
    local files = listdir (chisel.libdir .. "/data/" .. manufacturer)
    return imap (fix_name, ifilter (files, is_valid_device_name))
  end
end

device.list = list_devices


--- Obtains the device identifier from a PPD.
--
-- The identifier is expected to be found in the `*chiselDeviceId`
-- attribute. This will work flawlessly for PPDs generated by
-- @{device:ppd}.
--
-- @param ppd String containing the PPD data.
-- @return Device identifier (string), or `nil` if not found in the input.
--
function device.id_from_ppd (ppd)
  return ppd:match ("\n%*chiselDeviceId:%s*\"([^\"]+)\"\n")
end

--- Obtains the renderer to be used from a PPD.
--
-- The renderer name is expected to be found in the `*chiselRenderer`
-- attribute. This will work flawlessly for PPDs generated by
-- @{device:ppd}.
--
-- @param ppd String containing the PPD data.
-- @return Device renderer (string), or `nil` if not found in the input.
--
function device.renderer_from_ppd (ppd)
  return ppd:match ("\n%*chiselRenderer:%s*\"([^\"]+)\"\n")
end

return device
